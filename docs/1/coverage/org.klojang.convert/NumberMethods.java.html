<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NumberMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Convert</a> &gt; <a href="index.source.html" class="el_package">org.klojang.convert</a> &gt; <span class="el_source">NumberMethods.java</span></div><h1>NumberMethods.java</h1><pre class="source lang-java linenums">package org.klojang.convert;

import org.klojang.check.Check;
import org.klojang.util.ClassMethods;
import org.klojang.util.MathMethods;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;

import static java.math.BigDecimal.ONE;
import static org.klojang.util.ClassMethods.*;
import static org.klojang.util.ObjectMethods.isEmpty;
import static org.klojang.convert.ToFloatConversion.BIG_MAX_FLOAT;
import static org.klojang.convert.ToFloatConversion.BIG_MIN_FLOAT;
import static org.klojang.convert.TypeConversionException.inputTypeNotSupported;

/**
 * Methods for parsing, inspecting and converting {@code Number} instances.
 *
 * &lt;p&gt;NB For mathematical operations, see {@link MathMethods}.
 *
 * @author Ayco Holleman
 */
public final class NumberMethods {

  /**
   * {@code Double.MIN_VALUE} converted to a {@code BigDecimal}.
   */
<span class="fc" id="L35">  public static final BigDecimal MIN_DOUBLE_BD =</span>
<span class="fc" id="L36">      new BigDecimal(Double.toString(Double.MIN_VALUE));</span>

  /**
   * {@code Double.MAX_VALUE} converted to a {@code BigDecimal}.
   */
<span class="fc" id="L41">  public static final BigDecimal MAX_DOUBLE_BD =</span>
<span class="fc" id="L42">      new BigDecimal(Double.toString(Double.MAX_VALUE));</span>

  /**
   * {@code Long.MIN_VALUE} converted to a {@code BigDecimal}.
   */
<span class="fc" id="L47">  public static final BigDecimal MIN_LONG_BD =</span>
      new BigDecimal(Long.MIN_VALUE);

  /**
   * {@code Long.MAX_VALUE} converted to a {@code BigDecimal}.
   */
<span class="fc" id="L53">  public static final BigDecimal MAX_LONG_BD =</span>
      new BigDecimal(Long.MAX_VALUE);

  /**
   * {@code Long.MIN_VALUE} converted to a {@code BigInteger}.
   */
<span class="fc" id="L59">  public static final BigInteger MIN_LONG_BI =</span>
<span class="fc" id="L60">      BigInteger.valueOf(Long.MIN_VALUE);</span>

  /**
   * {@code Long.MAX_VALUE} converted to a {@code BigInteger}.
   */
<span class="fc" id="L65">  public static final BigInteger MAX_LONG_BI =</span>
<span class="fc" id="L66">      BigInteger.valueOf(Long.MAX_VALUE);</span>

<span class="fc" id="L68">  static Predicate&lt;Number&gt; yes() {return n -&gt; true;}</span>

  private static final Map&lt;Class&lt;? extends Number&gt;, Function&lt;Number, BigDecimal&gt;&gt;
<span class="fc" id="L71">      toBigDecimal =</span>
<span class="fc" id="L72">      Map.of(</span>
<span class="fc" id="L73">          BigDecimal.class, BigDecimal.class::cast,</span>
<span class="fc" id="L74">          BigInteger.class, x -&gt; new BigDecimal((BigInteger) x),</span>
<span class="fc" id="L75">          Double.class, x -&gt; new BigDecimal(Double.toString((double) x)),</span>
<span class="fc" id="L76">          Float.class, x -&gt; new BigDecimal(Float.toString((float) x)),</span>
<span class="fc" id="L77">          Long.class, x -&gt; new BigDecimal((Long) x),</span>
<span class="fc" id="L78">          AtomicLong.class, x -&gt; new BigDecimal(((AtomicLong) x).get()),</span>
<span class="fc" id="L79">          Integer.class, x -&gt; new BigDecimal((Integer) x),</span>
<span class="fc" id="L80">          AtomicInteger.class, x -&gt; new BigDecimal(((AtomicInteger) x).get()),</span>
<span class="fc" id="L81">          Short.class, x -&gt; new BigDecimal((Short) x),</span>
<span class="fc" id="L82">          Byte.class, x -&gt; new BigDecimal((Byte) x)</span>
      );

<span class="fc" id="L85">  private static final Map&lt;Class&lt;?&gt;, Function&lt;String, Number&gt;&gt; parsers = Map.of(</span>
      BigDecimal.class, NumberMethods::parseBigDecimal,
      BigInteger.class, NumberMethods::parseBigInteger,
      Double.class, NumberMethods::parseDouble,
      Float.class, NumberMethods::parseFloat,
      Long.class, NumberMethods::parseLong,
<span class="fc" id="L91">      AtomicLong.class, s -&gt; new AtomicLong(parseLong(s)),</span>
      Integer.class, NumberMethods::parseInt,
<span class="fc" id="L93">      AtomicInteger.class, s -&gt; new AtomicInteger(parseInt(s)),</span>
      Short.class, NumberMethods::parseShort,
      Byte.class, NumberMethods::parseByte);

<span class="fc" id="L97">  private static final Map&lt;Class&lt;?&gt;, Predicate&lt;String&gt;&gt; stringFitsInto = Map.of(</span>
      BigDecimal.class, NumberMethods::isBigDecimal,
      BigInteger.class, NumberMethods::isBigInteger,
      Double.class, NumberMethods::isDouble,
      Float.class, NumberMethods::isFloat,
      Long.class, NumberMethods::isLong,
      AtomicLong.class, NumberMethods::isLong,
      Integer.class, NumberMethods::isInt,
      AtomicInteger.class, NumberMethods::isInt,
      Short.class, NumberMethods::isShort,
      Byte.class, NumberMethods::isByte);

<span class="fc" id="L109">  private static final Map&lt;Class&lt;?&gt;, Predicate&lt;Number&gt;&gt; numberFitsInto = Map.of(</span>
      BigDecimal.class, ToBigDecimalConversion::isLossless,
      BigInteger.class, ToBigIntegerConversion::isLossless,
      Double.class, ToDoubleConversion::isLossless,
      Float.class, ToFloatConversion::isLossless,
      Long.class, ToLongConversion::isLossless,
      AtomicLong.class, ToLongConversion::isLossless,
      Integer.class, ToIntConversion::isLossless,
      AtomicInteger.class, ToIntConversion::isLossless,
      Short.class, ToShortConversion::isLossless,
      Byte.class, ToByteConversion::isLossless);

<span class="fc" id="L121">  private static final Map&lt;Class&lt;?&gt;, UnaryOperator&lt;Number&gt;&gt; converters = Map.of(</span>
      BigDecimal.class, ToBigDecimalConversion::exec,
      BigInteger.class, ToBigIntegerConversion::exec,
      Double.class, ToDoubleConversion::exec,
      Float.class, ToFloatConversion::exec,
      Long.class, ToLongConversion::exec,
      AtomicLong.class, ToLongConversion::exec,
      Integer.class, ToIntConversion::exec,
      AtomicInteger.class, ToIntConversion::exec,
      Short.class, ToShortConversion::exec,
      Byte.class, ToByteConversion::exec);

<span class="fc" id="L133">  private static final Set&lt;Class&lt;? extends Number&gt;&gt; wrappers = Set.of(Byte.class,</span>
      Short.class,
      Integer.class,
      Long.class,
      Float.class,
      Double.class);

<span class="fc" id="L140">  private static final Set&lt;Class&lt;? extends Number&gt;&gt; integrals = Set.of(Byte.class,</span>
      Short.class,
      Integer.class,
      AtomicInteger.class,
      Long.class,
      AtomicLong.class,
      BigInteger.class);

<span class="fc" id="L148">  private static final Set&lt;Class&lt;? extends Number&gt;&gt; supported = Set.of(Byte.class,</span>
      Short.class,
      Integer.class,
      AtomicInteger.class,
      Long.class,
      AtomicLong.class,
      Float.class,
      Double.class,
      BigInteger.class,
      BigDecimal.class);

<span class="nc" id="L159">  private NumberMethods() {</span>
<span class="nc" id="L160">    throw new UnsupportedOperationException();</span>
  }

  /**
   * Returns {@code true} if the specified class is one of the standard primitive
   * number wrappers: {@code Byte}, {@code Short}, {@code Integer}, {@code Long},
   * {@code Float}, {@code Double}.
   *
   * @param numberType the class to test
   * @return whether the class is a primitive number wrapper
   * @see ClassMethods#isPrimitiveNumber(Class)
   */
  public static boolean isWrapper(Class&lt;?&gt; numberType) {
<span class="fc" id="L173">    Check.notNull(numberType);</span>
<span class="fc" id="L174">    return wrappers.contains(numberType);</span>
  }

  /**
   * Returns {@code true} if  the specified number belongs to one of the primitive
   * number wrappers.
   *
   * @param number the number to test
   * @return whether the specified number belongs to one of the primitive number
   *     wrappers
   * @see #isWrapper(Class)
   */
  public static boolean isWrapper(Number number) {
<span class="fc" id="L187">    Check.notNull(number);</span>
<span class="fc" id="L188">    return wrappers.contains(number.getClass());</span>
  }

  /**
   * Returns {@code true} if the specified class is one of {@code Byte},
   * {@code Short}, {@code Integer}, {@code Long}, {@code BigInteger}.
   *
   * @param type the class to test
   * @return whether the class is an integral number type
   */
  public static boolean isIntegral(Class&lt;?&gt; type) {
<span class="fc" id="L199">    return Check.notNull(type).ok(integrals::contains);</span>
  }

  /**
   * Returns {@code true} if the specified number is an integral number.
   *
   * @param number the number to test
   * @return whether the specified number is an integral number
   * @see #isIntegral(Class)
   */
  public static boolean isIntegral(Number number) {
<span class="fc" id="L210">    Check.notNull(number);</span>
<span class="fc" id="L211">    return integrals.contains(number.getClass());</span>
  }

  /**
   * Parses the specified string into a {@code int}. If the string does not represent
   * a number, or if it cannot be parsed into an {@code int} without loss of
   * information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code int} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static int parseInt(String s) throws TypeConversionException {
<span class="fc" id="L225">    return (int) parseIntegral(s, int.class, Integer.MIN_VALUE, Integer.MAX_VALUE);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into an {@code int}
   * without loss of information. The argument is allowed to be {@code null}, in
   * which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether the specified string can be parsed into an {@code int} without
   *     causing integer overflow
   */
  public static boolean isInt(String s) {
<span class="fc" id="L238">    return isIntegral(s, Integer.MIN_VALUE, Integer.MAX_VALUE);</span>
  }

  /**
   * Returns an empty {@code OptionalInt} if the specified string cannot be parsed
   * into a 32-bit integer, else an {@code OptionalInt} containing the {@code int}
   * value parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code OptionalInt} containing the {@code int} value parsed out of
   *     the string
   */
  public static OptionalInt toInt(String s) {
<span class="fc" id="L251">    return toIntegral(s, Integer.MIN_VALUE, Integer.MAX_VALUE);</span>
  }

  /**
   * Parses the specified string into a {@code long}. If the string does not
   * represent a number, or if it cannot be parsed into a {@code long} without loss
   * of information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code long} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static long parseLong(String s) throws TypeConversionException {
<span class="fc bfc" id="L265" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      BigDecimal bd;
      try {
<span class="fc" id="L268">        bd = new BigDecimal(s);</span>
<span class="fc" id="L269">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L270">        throw new TypeConversionException(s, long.class, e.toString());</span>
<span class="fc" id="L271">      }</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">      if (fitsIntoLong(bd)) {</span>
<span class="fc" id="L273">        return bd.longValue();</span>
      }
<span class="fc" id="L275">      throw TypeConversionException.targetTypeTooNarrow(s, long.class);</span>
    }
<span class="fc" id="L277">    throw new TypeConversionException(s, long.class);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a {@code long}
   * without loss of information. The argument is allowed to be {@code null}, in
   * which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether the specified string can be parsed into a {@code long} without
   *     causing integer overflow
   */
  public static boolean isLong(String s) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L292">        return fitsIntoLong(new BigDecimal(s));</span>
<span class="nc" id="L293">      } catch (NumberFormatException ignored) {</span>
      }
    }
<span class="fc" id="L296">    return false;</span>
  }

  /**
   * Returns an empty {@code OptionalLong} if the specified string cannot be parsed
   * into a 64-bit integer, else an {@code OptionalLong} containing the {@code long}
   * value parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code OptionalLong} containing the {@code long} value parsed out of
   *     the string
   */
  public static OptionalLong toLong(String s) {
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L311">        BigDecimal bd = new BigDecimal(s);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (fitsIntoLong(bd)) {</span>
<span class="fc" id="L313">          return OptionalLong.of(bd.longValue());</span>
        }
<span class="fc" id="L315">      } catch (NumberFormatException ignored) {</span>
<span class="fc" id="L316">      }</span>
    }
<span class="fc" id="L318">    return OptionalLong.empty();</span>
  }

  /**
   * Parses the specified string into a {@code double}. If the string does not
   * represent a number, or if it cannot be parsed into a {@code double} without loss
   * of information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code double} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static double parseDouble(String s) throws TypeConversionException {
<span class="fc bfc" id="L332" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      BigDecimal bd;
      try {
<span class="fc" id="L335">        bd = new BigDecimal(s);</span>
<span class="fc" id="L336">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L337">        throw new TypeConversionException(s, double.class, e.toString());</span>
<span class="fc" id="L338">      }</span>
<span class="fc" id="L339">      BigDecimal x = bd.abs();</span>
<span class="fc bfc" id="L340" title="All 4 branches covered.">      if (x.compareTo(MIN_DOUBLE_BD) &gt;= 0 &amp;&amp; x.compareTo(</span>
          MAX_DOUBLE_BD) &lt;= 0) {
<span class="fc" id="L342">        return bd.doubleValue();</span>
      }
    }
<span class="fc" id="L345">    throw TypeConversionException.targetTypeTooNarrow(s, float.class);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a {@code double}
   * without loss of information. The argument is allowed to be {@code null}, in
   * which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether he specified string can be parsed into a regular, finite
   *     {@code double}
   */
  public static boolean isDouble(String s) {
<span class="fc bfc" id="L358" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L360">        parseDouble(s);</span>
<span class="fc" id="L361">        return true;</span>
<span class="fc" id="L362">      } catch (TypeConversionException ignored) {</span>
      }
    }
<span class="fc" id="L365">    return false;</span>
  }

  /**
   * Returns an empty {@code OptionalDouble} if the specified string cannot be parsed
   * into a {@code double} value, else an {@code OptionalDouble} containing the
   * {@code double} value parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code OptionalDouble} containing the {@code double} value parsed out
   *     of the string
   */
  public static OptionalDouble toDouble(String s) {
<span class="fc bfc" id="L378" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L380">        return OptionalDouble.of(parseDouble(s));</span>
<span class="fc" id="L381">      } catch (TypeConversionException ignored) {</span>
      }
    }
<span class="fc" id="L384">    return OptionalDouble.empty();</span>
  }

  /**
   * Parses the specified string into a {@code float}. If the string does not
   * represent a number, or if it cannot be parsed into a {@code float} without loss
   * of information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code float} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static float parseFloat(String s) throws TypeConversionException {
<span class="fc bfc" id="L398" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      BigDecimal bd;
      try {
<span class="fc" id="L401">        bd = new BigDecimal(s);</span>
<span class="fc" id="L402">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L403">        throw new TypeConversionException(s, double.class, e.toString());</span>
<span class="fc" id="L404">      }</span>
<span class="fc" id="L405">      BigDecimal x = bd.abs();</span>
<span class="fc bfc" id="L406" title="All 4 branches covered.">      if (x.compareTo(BIG_MIN_FLOAT) &gt;= 0 &amp;&amp; x.compareTo(BIG_MAX_FLOAT) &lt;= 0) {</span>
<span class="fc" id="L407">        return bd.floatValue();</span>
      }
    }
<span class="fc" id="L410">    throw TypeConversionException.targetTypeTooNarrow(s, float.class);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a {@code float}
   * without loss of information. The argument is allowed to be {@code null}, in
   * which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether he specified string can be parsed into a regular, finite
   *     {@code float}
   */
  public static boolean isFloat(String s) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L425">        parseFloat(s);</span>
<span class="fc" id="L426">        return true;</span>
<span class="fc" id="L427">      } catch (TypeConversionException ignored) {</span>
      }
    }
<span class="fc" id="L430">    return false;</span>
  }

  /**
   * Returns an empty {@code OptionalDouble} if the specified string cannot be parsed
   * into a regular, finite {@code float} value, else an {@code OptionalDouble}
   * containing the {@code float} value parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code OptionalDouble} containing the {@code float} value parsed out
   *     of the string
   */
  public static OptionalDouble toFloat(String s) {
<span class="fc bfc" id="L443" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L445">        return OptionalDouble.of(parseFloat(s));</span>
<span class="fc" id="L446">      } catch (TypeConversionException ignored) {</span>
      }
    }
<span class="fc" id="L449">    return OptionalDouble.empty();</span>
  }

  /**
   * Parses the specified string into a {@code short}. If the string does not
   * represent a number, or if it cannot be parsed into a {@code short} without loss
   * of information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code short} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static short parseShort(String s) throws TypeConversionException {
<span class="fc" id="L463">    return (short) parseIntegral(s, short.class, Short.MIN_VALUE, Short.MAX_VALUE);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a {@code short}
   * without loss of information. The argument is allowed to be {@code null}, in
   * which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether he specified string can be parsed into a {@code short} without
   *     causing integer overflow
   */
  public static boolean isShort(String s) {
<span class="fc" id="L476">    return isIntegral(s, Short.MIN_VALUE, Short.MAX_VALUE);</span>
  }

  /**
   * Returns an empty {@code OptionalInt} if the specified string cannot be parsed
   * into a 16-bit integer, else an {@code OptionalInt} containing the {@code short}
   * value parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code OptionalInt} containing the {@code short} value parsed out of
   *     the string
   */
  public static OptionalInt toShort(String s) {
<span class="fc" id="L489">    return toIntegral(s, Short.MIN_VALUE, Short.MAX_VALUE);</span>
  }

  /**
   * Parses the specified string into a {@code byte}. If the string does not
   * represent a number, or if it cannot be parsed into a {@code byte} without loss
   * of information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code byte} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static byte parseByte(String s) throws TypeConversionException {
<span class="fc" id="L503">    return (byte) parseIntegral(s, byte.class, Byte.MIN_VALUE, Byte.MAX_VALUE);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a {@code byte}
   * without loss of information. The argument is allowed to be {@code null}, in
   * which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether he specified string can be parsed into a {@code byte} without
   *     causing an integer overflow
   */
  public static boolean isByte(String s) {
<span class="fc" id="L516">    return isIntegral(s, Byte.MIN_VALUE, Byte.MAX_VALUE);</span>
  }

  /**
   * Returns an empty {@code OptionalInt} if the specified string cannot be parsed
   * into an 8-bit integer, else an {@code OptionalInt} containing the {@code byte}
   * value parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code OptionalInt} containing the {@code byte} value parsed out of
   *     the string
   */
  public static OptionalInt toByte(String s) {
<span class="fc" id="L529">    return toIntegral(s, Byte.MIN_VALUE, Byte.MAX_VALUE);</span>
  }

  /**
   * Parses the specified string into a {@code BigInteger}. If the string does not
   * represent a number, or if it cannot be parsed into a {@code BigInteger} without
   * loss of information, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code BigInteger} value represented by the string
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  public static BigInteger parseBigInteger(String s) throws TypeConversionException {
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L545">        BigDecimal bd = new BigDecimal(s);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (isRound(bd)) {</span>
<span class="fc" id="L547">          return bd.toBigInteger();</span>
        }
<span class="fc" id="L549">        throw TypeConversionException.targetTypeTooNarrow(s, BigInteger.class);</span>
<span class="fc" id="L550">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L551">        throw new TypeConversionException(s, BigInteger.class, e.toString());</span>
      }
    }
<span class="nc" id="L554">    throw new TypeConversionException(s, BigInteger.class);</span>
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a
   * {@code BigInteger} without loss of information. The argument is allowed to be
   * {@code null}, in which case the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether he specified string can be parsed into a {@code BigInteger}
   */
  public static boolean isBigInteger(String s) {
<span class="fc bfc" id="L566" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L568">        BigDecimal bd = new BigDecimal(s);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        if (isRound(bd)) {</span>
<span class="fc" id="L570">          return true;</span>
        }
<span class="nc" id="L572">      } catch (NumberFormatException ignored) {</span>
<span class="fc" id="L573">      }</span>
    }
<span class="fc" id="L575">    return false;</span>
  }

  /**
   * Returns an empty {@code Optional} if the specified string cannot be parsed into
   * BigInteger, else an {@code Optional} containing the {@code BigInteger} value
   * parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code Optional} containing the {@code BigInteger} value parsed out
   *     of the string
   */
  public static Optional&lt;BigInteger&gt; toBigInteger(String s) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L590">        BigDecimal bd = new BigDecimal(s);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">        if (isRound(bd)) {</span>
<span class="fc" id="L592">          return Optional.of(bd.toBigInteger());</span>
        }
<span class="nc" id="L594">      } catch (NumberFormatException ignored) {</span>
<span class="fc" id="L595">      }</span>
    }
<span class="fc" id="L597">    return Optional.empty();</span>
  }

  /**
   * Parses the specified string into a {@code BigInteger}. If the string does not
   * represent a number, a {@link TypeConversionException} is thrown.
   *
   * @param s the string to be parsed
   * @return the {@code BigDecimal} value represented by the string
   * @throws TypeConversionException if the string does not represent or number
   */
  public static BigDecimal parseBigDecimal(String s) throws TypeConversionException {
    try {
<span class="fc" id="L610">      return new BigDecimal(s);</span>
<span class="fc" id="L611">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L612">      throw new TypeConversionException(s, BigDecimal.class, e.toString());</span>
    }
  }

  /**
   * Returns {@code true} if the specified string can be parsed into a
   * {@code BigDecimal}. The argument is allowed to be {@code null}, in which case
   * the return value will be {@code false}.
   *
   * @param s the string to be parsed
   * @return whether he specified string can be parsed into a {@code BigDecimal}
   */
  public static boolean isBigDecimal(String s) {
<span class="fc bfc" id="L625" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L627">        parseBigDecimal(s);</span>
<span class="fc" id="L628">        return true;</span>
<span class="fc" id="L629">      } catch (TypeConversionException ignored) {</span>
      }
    }
<span class="fc" id="L632">    return false;</span>
  }

  /**
   * Returns an empty {@code Optional} if the specified string cannot be parsed into
   * BigDecimal, else an {@code Optional} containing the {@code BigDecimal} value
   * parsed out of the string.
   *
   * @param s the string to be parsed
   * @return an {@code Optional} containing the {@code BigDecimal} value parsed out
   *     of the string
   */
  public static Optional&lt;BigDecimal&gt; toBigDecimal(String s) {
<span class="fc bfc" id="L645" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L647">        return Optional.of(parseBigDecimal(s));</span>
<span class="fc" id="L648">      } catch (TypeConversionException ignored) {</span>
      }
    }
<span class="fc" id="L651">    return Optional.empty();</span>
  }

  /**
   * Parses the specified string into a number of the specified type. Throws an
   * {@link TypeConversionException} if the string is not a number, or if the number
   * is too big to fit into the target type.
   *
   * @param &lt;T&gt; the type of {@code Number} to convert the string to
   * @param s the string to be parsed
   * @param targetType the class of the {@code Number} type
   * @return a {@code Number} of the specified type
   * @throws TypeConversionException if the string does not represent or number,
   *     or if conversion would lead to loss of information
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T extends Number&gt; T parse(String s, Class&lt;T&gt; targetType)
      throws TypeConversionException {
<span class="fc" id="L669">    Check.notNull(targetType, &quot;target type&quot;);</span>
<span class="fc" id="L670">    Function&lt;String, Number&gt; parser = parsers.get(targetType);</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">    if (parser != null) {</span>
<span class="fc" id="L672">      return (T) parser.apply(s);</span>
    }
<span class="fc" id="L674">    throw notSupported(s, targetType);</span>
  }

  /**
   * Tests whether the specified string can be parsed into a {@code Number} of the
   * specified type.
   *
   * @param &lt;T&gt; the type of {@code Number} to convert the string to
   * @param s the string to be parsed
   * @param targetType the class of the {@code Number} type
   * @return whether the specified string can be parsed into a {@code Number} of the
   *     specified type
   */
  public static &lt;T extends Number&gt; boolean fitsInto(String s, Class&lt;T&gt; targetType) {
<span class="fc" id="L688">    Check.notNull(targetType, &quot;target type&quot;);</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
<span class="fc" id="L690">      Predicate&lt;String&gt; tester = stringFitsInto.get(targetType);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">      if (tester != null) {</span>
<span class="fc" id="L692">        return tester.test(s);</span>
      }
<span class="fc" id="L694">      throw notSupported(s, targetType);</span>
    }
<span class="fc" id="L696">    return false;</span>
  }

  ////////////////////////////////////////////////////////////////////////////////
  //                           END OF PARSE METHODS                             //
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * Converts a {@code Number} of an unspecified type to a {@code BigDecimal}.
   *
   * @param n the number
   * @return the {@code BigDecimal} representing the number
   */
  public static BigDecimal toBigDecimal(Number n) {
<span class="fc" id="L710">    Check.notNull(n);</span>
<span class="fc" id="L711">    Function&lt;Number, BigDecimal&gt; fnc = toBigDecimal.get(n.getClass());</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">    if (fnc != null) {</span>
<span class="fc" id="L713">      return fnc.apply(n);</span>
    }
<span class="fc" id="L715">    throw inputTypeNotSupported(n, BigDecimal.class);</span>
  }

  /**
   * Safely converts a number of an unspecified type to a number of a definite type.
   * Throws a {@link TypeConversionException} if the number cannot be converted to
   * the target type without loss of information. The number is allowed to be
   * {@code null}, in which case {@code null} will be returned.
   *
   * @param &lt;T&gt; the input type
   * @param &lt;R&gt; the output type
   * @param number the number to be converted
   * @param targetType the class of the target type
   * @return an instance of the target type
   */
  @SuppressWarnings({&quot;unchecked&quot;})
  public static &lt;T extends Number, R extends Number&gt; R convert(T number,
      Class&lt;R&gt; targetType) throws TypeConversionException {
<span class="fc" id="L733">    Check.notNull(targetType, &quot;target type&quot;);</span>
<span class="fc bfc" id="L734" title="All 4 branches covered.">    if (number == null || number.getClass() == targetType) {</span>
<span class="fc" id="L735">      return (R) number;</span>
    }
<span class="fc" id="L737">    UnaryOperator&lt;Number&gt; fnc = converters.get(targetType);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">    if (fnc != null) {</span>
<span class="fc" id="L739">      return (R) fnc.apply(number);</span>
    }
<span class="fc" id="L741">    throw notSupported(number, targetType);</span>
  }

  /**
   * Returns {@code true} if the specified number can be converted to the specified
   * target type without loss of information. The number is allowed to be
   * {@code null}, in which case {@code true} will be returned.
   *
   * @param &lt;T&gt; the type of {@code Number} to convert to
   * @param number the {@code Number} to convert
   * @param targetType the type of {@code Number} to convert to
   * @return whether conversion will be lossless
   */
  public static &lt;T extends Number&gt; boolean fitsInto(Number number,
      Class&lt;T&gt; targetType) {
<span class="fc" id="L756">    Check.notNull(targetType, &quot;target type&quot;);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">    if (number == null) {</span>
<span class="fc" id="L758">      return true;</span>
    }
<span class="fc" id="L760">    Predicate&lt;Number&gt; tester = numberFitsInto.get(targetType);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">    if (tester != null) {</span>
<span class="fc" id="L762">      return tester.test(number);</span>
    }
<span class="fc" id="L764">    throw inputTypeNotSupported(number, targetType);</span>
  }

  /**
   * Determines whether the specified float's fractional part is zero or absent.
   *
   * @param f the {@code float} to inspect
   * @return whether the specified float's fractional part is zero or absent
   */
  public static boolean isRound(float f) {
<span class="fc" id="L774">    return isRound(new BigDecimal(Float.toString(f)));</span>
  }

  /**
   * Determines whether the specified double's fractional part is zero or absent.
   *
   * @param d the {@code double} to inspect
   * @return whether the specified double's fractional part is zero or absent
   */
  public static boolean isRound(double d) {
<span class="fc" id="L784">    return isRound(new BigDecimal(Double.toString(d)));</span>
  }

  /**
   * Determines whether the specified BigDecimal's fractional part is zero or
   * absent.
   *
   * @param bd the {@code BigDecimal} to inspect
   * @return whether the specified BigDecimal's fractional part is zero or absent
   */
  public static boolean isRound(BigDecimal bd) {
    // NB The 1st check is cheap and catches a lot of the cases.
    // The 2nd second is superfluous in the presence of the 3rd.
    // However, it still catches quite a few cases and seems
    // sufficiently cheap compared to the 3rd check that it seems
    // worth paying the price of wasted CPU cycles if we do fall
    // through to the 3rd check. The 3rd and 4th check are
    // equivalent, but the 3rd check seems more efficient. Needs
    // to be measured though.
<span class="fc bfc" id="L803" title="All 2 branches covered.">    return bd.scale() &lt;= 0</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        || bd.stripTrailingZeros().scale() == 0</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">        || bd.divideToIntegralValue(ONE).compareTo(bd) == 0</span>
        /*|| bd.remainder(ONE).signum() == 0 */;
  }

  private static long parseIntegral(String s,
      Class&lt;?&gt; type,
      long minVal,
      long maxVal) {
<span class="fc bfc" id="L813" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L815">        BigDecimal bd = new BigDecimal(s);</span>
        long l;
<span class="fc bfc" id="L817" title="All 6 branches covered.">        if (isRound(bd) &amp;&amp; (l = bd.longValue()) &gt;= minVal &amp;&amp; l &lt;= maxVal) {</span>
<span class="fc" id="L818">          return l;</span>
        }
<span class="fc" id="L820">        throw TypeConversionException.targetTypeTooNarrow(s, type);</span>
<span class="fc" id="L821">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L822">        throw new TypeConversionException(s, int.class, e.toString());</span>
      }
    }
<span class="fc" id="L825">    throw new TypeConversionException(s, type);</span>
  }

  private static boolean isIntegral(String s, long minVal, long maxVal) {
<span class="fc bfc" id="L829" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L831">        BigDecimal bd = new BigDecimal(s);</span>
        long l;
<span class="pc bpc" id="L833" title="2 of 6 branches missed.">        return isRound(bd) &amp;&amp; (l = bd.longValue()) &gt;= minVal &amp;&amp; l &lt;= maxVal;</span>
<span class="nc" id="L834">      } catch (NumberFormatException ignored) {</span>
      }
    }
<span class="fc" id="L837">    return false;</span>
  }

  private static OptionalInt toIntegral(String s, long minVal, long maxVal) {
<span class="fc bfc" id="L841" title="All 2 branches covered.">    if (!isEmpty(s)) {</span>
      try {
<span class="fc" id="L843">        BigDecimal bd = new BigDecimal(s);</span>
        long l;
<span class="pc bpc" id="L845" title="1 of 6 branches missed.">        if (isRound(bd) &amp;&amp; (l = bd.longValue()) &gt;= minVal &amp;&amp; l &lt;= maxVal) {</span>
<span class="fc" id="L846">          return OptionalInt.of((int) l);</span>
        }
<span class="fc" id="L848">      } catch (NumberFormatException ignored) {</span>
<span class="fc" id="L849">      }</span>
    }
<span class="fc" id="L851">    return OptionalInt.empty();</span>
  }

  private static boolean fitsIntoLong(BigDecimal bd) {
<span class="fc bfc" id="L855" title="All 2 branches covered.">    return isRound(bd)</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        &amp;&amp; bd.compareTo(MIN_LONG_BD) &gt;= 0</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">        &amp;&amp; bd.compareTo(MAX_LONG_BD) &lt;= 0;</span>
  }

  private static TypeConversionException notSupported(Object obj,
      Class&lt;?&gt; type) {
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">    if (isPrimitiveNumber(type)) {</span>
<span class="nc" id="L863">      String fmt = &quot;primitive types not supported *** call ClassMethods.box to convert %s to %s&quot;;</span>
<span class="nc" id="L864">      String c0 = type.getName();</span>
<span class="nc" id="L865">      String c1 = box(type).getSimpleName();</span>
<span class="nc" id="L866">      return new TypeConversionException(obj, type, fmt, c0, c1);</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">    } else if (isSubtype(type, Number.class)) {</span>
<span class="fc" id="L868">      String c0 = type.getSimpleName();</span>
<span class="fc" id="L869">      return new TypeConversionException(obj, type, &quot;%s not supported&quot;, c0);</span>
    }
<span class="fc" id="L871">    String msg = &quot;target type must be subclass of Number&quot;;</span>
<span class="fc" id="L872">    return new TypeConversionException(obj, type, msg);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>